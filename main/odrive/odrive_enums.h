#ifndef ODRIVE_ENUMS_H
#define ODRIVE_ENUMS_H

#ifdef __cplusplus
extern "C" {
#endif

// Enums are based on the ones from the python library

// TODO: Prefix all enums with "Odrive" to avoid name clashes

/**
 * @brief ODrive Command IDs.
 *
 * See:
 * https://docs.odriverobotics.com/v/latest/manual/can-protocol.html#overview
 * for more information.
 *
 * @note
 * - All "Get_" messages can be set as cyclic messages or requested by the
 * master (with the RTR bit set).
 * - In response, the ODrive sends back the same message ID and the
 * corresponding payload.
 */
typedef enum {
    CMD_GET_VERSION = 0x00,             // with response
    CMD_HEARTBEAT = 0x01,               // with response
    CMD_ESTOP = 0x02,                   // no response
    CMD_GET_ERROR = 0x03,               // with response
    CMD_RXSDO = 0x04,                   // with txsdo response
    CMD_TXSDO = 0x05,                   // response of rxsdo (this should not be sent by the master)
    CMD_ADRESS = 0x06,                  // with response
    CMD_SET_AXIS_STATE = 0x07,          // no response -> use heartbeat to check if state is reached
    CMD_GET_ENCODER_ESTIMATES = 0x09,   // with response
    CMD_SET_CONTROL_MODE = 0x0b,        // no response
    CMD_SET_INPUT_POS = 0x0c,           // no response
    CMD_SET_INPUT_VEL = 0x0d,           // no response
    CMD_SET_INPUT_TORQUE = 0x0e,        // no response
    CMD_SET_LIMITS = 0x0f,              // no response
    CMD_SET_TRAJ_VEL_LIMIT = 0x11,      // no response
    CMD_SET_TRAJ_ACCEL_LIMIT = 0x12,    // no response
    CMD_SET_TRAJ_INERTIA = 0x13,        // no response
    CMD_GET_IQ = 0x14,                  // with response
    CMD_GET_TEMPERATURE = 0x15,         // with response
    CMD_REBOOT = 0x16,                  // no response
    CMD_GET_BUS_VOLTAGE_CURRENT = 0x17, // with response
    CMD_CLEAR_ERRORS = 0x18,            // no response
    CMD_SET_ABSOLUTE_POSITION = 0x19,   // no response
    CMD_SET_POS_GAIN = 0x1a,            // no response
    CMD_SET_VEL_GAINS = 0x1b,           // no response
    CMD_GET_TORQUES = 0x1c,             // with response
    CMD_GET_POWERS = 0x1d,              // with response
    CMD_ENTER_DFU_MODE = 0x1f           // no response
} ODriveCommand;

typedef enum {
    GPIO_MODE_DIGITAL = 0,
    GPIO_MODE_DIGITAL_PULL_UP = 1,
    GPIO_MODE_DIGITAL_PULL_DOWN = 2,
    GPIO_MODE_ANALOG_IN = 3,
    GPIO_MODE_UART_A = 4,
    GPIO_MODE_UART_B = 5,
    GPIO_MODE_UART_C = 6,
    GPIO_MODE_CAN_A = 7,
    GPIO_MODE_I2C_A = 8,
    GPIO_MODE_SPI_A = 9,
    GPIO_MODE_PWM = 10,
    GPIO_MODE_ENC0 = 11,
    GPIO_MODE_ENC1 = 12,
    GPIO_MODE_ENC2 = 13,
    GPIO_MODE_MECH_BRAKE = 14,
    GPIO_MODE_STATUS = 15,
    GPIO_MODE_BRAKE_RES = 16,
    GPIO_MODE_AUTO = 17
} GpioMode;

typedef enum {
    STREAM_PROTOCOL_TYPE_FIBRE = 0,
    STREAM_PROTOCOL_TYPE_ASCII = 1,
    STREAM_PROTOCOL_TYPE_STDOUT = 2,
    STREAM_PROTOCOL_TYPE_ASCII_AND_STDOUT = 3,
    STREAM_PROTOCOL_TYPE_OTHER = 4
} StreamProtocolType;

typedef enum {
    PROTOCOL_NONE = 0x00000000,
    PROTOCOL_SIMPLE = 0x00000001
} Protocol;

typedef enum {
    AXIS_STATE_UNDEFINED = 0,
    AXIS_STATE_IDLE = 1,
    AXIS_STATE_STARTUP_SEQUENCE = 2,
    AXIS_STATE_FULL_CALIBRATION_SEQUENCE = 3,
    AXIS_STATE_MOTOR_CALIBRATION = 4,
    AXIS_STATE_SENSORLESS_CONTROL = 5,
    AXIS_STATE_ENCODER_INDEX_SEARCH = 6,
    AXIS_STATE_ENCODER_OFFSET_CALIBRATION = 7,
    AXIS_STATE_CLOSED_LOOP_CONTROL = 8,
    AXIS_STATE_LOCKIN_SPIN = 9,
    AXIS_STATE_ENCODER_DIR_FIND = 10,
    AXIS_STATE_HOMING = 11,
    AXIS_STATE_ENCODER_HALL_POLARITY_CALIBRATION = 12,
    AXIS_STATE_ENCODER_HALL_PHASE_CALIBRATION = 13,
    AXIS_STATE_ANTICOGGING_CALIBRATION = 14
} AxisState;

typedef enum {
    CONTROL_MODE_VOLTAGE_CONTROL = 0,
    CONTROL_MODE_TORQUE_CONTROL = 1,
    CONTROL_MODE_VELOCITY_CONTROL = 2,
    CONTROL_MODE_POSITION_CONTROL = 3
} ControlMode;

typedef enum {
    COMPONENT_STATUS_NOMINAL = 0,
    COMPONENT_STATUS_NO_RESPONSE = 1,
    COMPONENT_STATUS_INVALID_RESPONSE_LENGTH = 2,
    COMPONENT_STATUS_PARITY_MISMATCH = 3,
    COMPONENT_STATUS_ILLEGAL_HALL_STATE = 4,
    COMPONENT_STATUS_POLARITY_NOT_CALIBRATED = 5,
    COMPONENT_STATUS_PHASES_NOT_CALIBRATED = 6,
    COMPONENT_STATUS_NUMERICAL_ERROR = 7,
    COMPONENT_STATUS_MISSING_INPUT = 8,
    COMPONENT_STATUS_RELATIVE_MODE = 9,
    COMPONENT_STATUS_UNCONFIGURED = 10,
    COMPONENT_STATUS_OVERSPEED = 11,
    COMPONENT_STATUS_INDEX_NOT_FOUND = 12,
    COMPONENT_STATUS_BAD_CONFIG = 13,
    COMPONENT_STATUS_NOT_ENABLED = 14,
    COMPONENT_STATUS_SPINOUT_DETECTED = 15
} ComponentStatus;

typedef enum {
    ODRIVE_ERROR_NONE = 0x00000000,
    ODRIVE_ERROR_INITIALIZING = 0x00000001,
    ODRIVE_ERROR_SYSTEM_LEVEL = 0x00000002,
    ODRIVE_ERROR_TIMING_ERROR = 0x00000004,
    ODRIVE_ERROR_MISSING_ESTIMATE = 0x00000008,
    ODRIVE_ERROR_BAD_CONFIG = 0x00000010,
    ODRIVE_ERROR_DRV_FAULT = 0x00000020,
    ODRIVE_ERROR_MISSING_INPUT = 0x00000040,
    ODRIVE_ERROR_DC_BUS_OVER_VOLTAGE = 0x00000100,
    ODRIVE_ERROR_DC_BUS_UNDER_VOLTAGE = 0x00000200,
    ODRIVE_ERROR_DC_BUS_OVER_CURRENT = 0x00000400,
    ODRIVE_ERROR_DC_BUS_OVER_REGEN_CURRENT = 0x00000800,
    ODRIVE_ERROR_CURRENT_LIMIT_VIOLATION = 0x00001000,
    ODRIVE_ERROR_MOTOR_OVER_TEMP = 0x00002000,
    ODRIVE_ERROR_INVERTER_OVER_TEMP = 0x00004000,
    ODRIVE_ERROR_VELOCITY_LIMIT_VIOLATION = 0x00008000,
    ODRIVE_ERROR_POSITION_LIMIT_VIOLATION = 0x00010000,
    ODRIVE_ERROR_WATCHDOG_TIMER_EXPIRED = 0x01000000,
    ODRIVE_ERROR_ESTOP_REQUESTED = 0x02000000,
    ODRIVE_ERROR_SPINOUT_DETECTED = 0x04000000,
    ODRIVE_ERROR_BRAKE_RESISTOR_DISARMED = 0x08000000,
    ODRIVE_ERROR_THERMISTOR_DISCONNECTED = 0x10000000,
    ODRIVE_ERROR_CALIBRATION_ERROR = 0x40000000
} ODriveError;

typedef enum {
    PROCEDURE_RESULT_SUCCESS = 0,
    PROCEDURE_RESULT_BUSY = 1,
    PROCEDURE_RESULT_CANCELLED = 2,
    PROCEDURE_RESULT_DISARMED = 3,
    PROCEDURE_RESULT_NO_RESPONSE = 4,
    PROCEDURE_RESULT_POLE_PAIR_CPR_MISMATCH = 5,
    PROCEDURE_RESULT_PHASE_RESISTANCE_OUT_OF_RANGE = 6,
    PROCEDURE_RESULT_PHASE_INDUCTANCE_OUT_OF_RANGE = 7,
    PROCEDURE_RESULT_UNBALANCED_PHASES = 8,
    PROCEDURE_RESULT_INVALID_MOTOR_TYPE = 9,
    PROCEDURE_RESULT_ILLEGAL_HALL_STATE = 10,
    PROCEDURE_RESULT_TIMEOUT = 11,
    PROCEDURE_RESULT_HOMING_WITHOUT_ENDSTOP = 12,
    PROCEDURE_RESULT_INVALID_STATE = 13,
    PROCEDURE_RESULT_NOT_CALIBRATED = 14,
    PROCEDURE_RESULT_NOT_CONVERGING = 15
} ProcedureResult;

typedef enum {
    ENCODER_ID_NONE = 0,
    ENCODER_ID_INC_ENCODER0 = 1,
    ENCODER_ID_INC_ENCODER1 = 2,
    ENCODER_ID_INC_ENCODER2 = 3,
    ENCODER_ID_SENSORLESS_ESTIMATOR = 4,
    ENCODER_ID_SPI_ENCODER0 = 5,
    ENCODER_ID_SPI_ENCODER1 = 6,
    ENCODER_ID_SPI_ENCODER2 = 7,
    ENCODER_ID_HALL_ENCODER0 = 8,
    ENCODER_ID_HALL_ENCODER1 = 9,
    ENCODER_ID_RS485_ENCODER0 = 10,
    ENCODER_ID_RS485_ENCODER1 = 11,
    ENCODER_ID_RS485_ENCODER2 = 12,
    ENCODER_ID_ONBOARD_ENCODER0 = 13,
    ENCODER_ID_ONBOARD_ENCODER1 = 14,
    ENCODER_ID_AMT21_ENCODER0 = 10,
    ENCODER_ID_AMT21_ENCODER1 = 11,
    ENCODER_ID_AMT21_ENCODER2 = 12
} EncoderId;

typedef enum {
    SPI_ENCODER_MODE_DISABLED = 0,
    SPI_ENCODER_MODE_RLS = 1,
    SPI_ENCODER_MODE_AMS = 2,
    SPI_ENCODER_MODE_CUI = 3,
    SPI_ENCODER_MODE_AEAT = 4,
    SPI_ENCODER_MODE_MA732 = 5,
    SPI_ENCODER_MODE_TLE = 6,
    SPI_ENCODER_MODE_BISSC = 7
} SpiEncoderMode;

typedef enum {
    RS485_ENCODER_MODE_DISABLED = 0,
    RS485_ENCODER_MODE_AMT21_POLLING = 1,
    RS485_ENCODER_MODE_AMT21_EVENT_DRIVEN = 2,
    RS485_ENCODER_MODE_MBS = 3,
    RS485_ENCODER_MODE_ODRIVE_OA1 = 4
} Rs485EncoderMode;

typedef enum {
    INPUT_MODE_INACTIVE = 0,
    INPUT_MODE_PASSTHROUGH = 1,
    INPUT_MODE_VEL_RAMP = 2,
    INPUT_MODE_POS_FILTER = 3,
    INPUT_MODE_MIX_CHANNELS = 4,
    INPUT_MODE_TRAP_TRAJ = 5,
    INPUT_MODE_TORQUE_RAMP = 6,
    INPUT_MODE_MIRROR = 7,
    INPUT_MODE_TUNING = 8
} InputMode;

typedef enum {
    MOTOR_TYPE_HIGH_CURRENT = 0,
    MOTOR_TYPE_GIMBAL = 2,
    MOTOR_TYPE_ACIM = 3
} MotorType;

typedef enum {
    CAN_ERROR_NONE = 0x00000000,
    CAN_ERROR_DUPLICATE_CAN_IDS = 0x00000001,
    CAN_ERROR_BUS_OFF = 0x00000002,
    CAN_ERROR_LOW_LEVEL = 0x00000004,
    CAN_ERROR_PROTOCOL_INIT = 0x00000008
} CanError;

typedef enum {
    AXIS_ERROR_NONE = 0x00000000,
    AXIS_ERROR_INVALID_STATE = 0x00000001,
    AXIS_ERROR_WATCHDOG_TIMER_EXPIRED = 0x00000800,
    AXIS_ERROR_MIN_ENDSTOP_PRESSED = 0x00001000,
    AXIS_ERROR_MAX_ENDSTOP_PRESSED = 0x00002000,
    AXIS_ERROR_ESTOP_REQUESTED = 0x00004000,
    AXIS_ERROR_HOMING_WITHOUT_ENDSTOP = 0x00020000,
    AXIS_ERROR_OVER_TEMP = 0x00040000,
    AXIS_ERROR_UNKNOWN_POSITION = 0x00080000,
    AXIS_ERROR_DC_BUS_UNDER_VOLTAGE = 0x00000002,
    AXIS_ERROR_DC_BUS_OVER_VOLTAGE = 0x00000004,
    AXIS_ERROR_CURRENT_MEASUREMENT_TIMEOUT = 0x00000008,
    AXIS_ERROR_BRAKE_RESISTOR_DISARMED = 0x00000010,
    AXIS_ERROR_MOTOR_DISARMED = 0x00000020,
    AXIS_ERROR_MOTOR_FAILED = 0x00000040,
    AXIS_ERROR_SENSORLESS_ESTIMATOR_FAILED = 0x00000080,
    AXIS_ERROR_ENCODER_FAILED = 0x00000100,
    AXIS_ERROR_CONTROLLER_FAILED = 0x00000200,
    AXIS_ERROR_POS_CTRL_DURING_SENSORLESS = 0x00000400
} AxisError;

typedef enum {
    MOTOR_ERROR_NONE = 0x00000000,
    MOTOR_ERROR_DRV_FAULT = 0x00000008,
    MOTOR_ERROR_CONTROL_DEADLINE_MISSED = 0x00000010,
    MOTOR_ERROR_MODULATION_MAGNITUDE = 0x00000080,
    MOTOR_ERROR_CURRENT_SENSE_SATURATION = 0x00000400,
    MOTOR_ERROR_CURRENT_LIMIT_VIOLATION = 0x00001000,
    MOTOR_ERROR_MODULATION_IS_NAN = 0x00010000,
    MOTOR_ERROR_MOTOR_THERMISTOR_OVER_TEMP = 0x00020000,
    MOTOR_ERROR_FET_THERMISTOR_OVER_TEMP = 0x00040000,
    MOTOR_ERROR_TIMER_UPDATE_MISSED = 0x00080000,
    MOTOR_ERROR_CURRENT_MEASUREMENT_UNAVAILABLE = 0x00100000,
    MOTOR_ERROR_CONTROLLER_FAILED = 0x00200000,
    MOTOR_ERROR_I_BUS_OUT_OF_RANGE = 0x00400000,
    MOTOR_ERROR_BRAKE_RESISTOR_DISARMED = 0x00800000,
    MOTOR_ERROR_SYSTEM_LEVEL = 0x01000000,
    MOTOR_ERROR_BAD_TIMING = 0x02000000,
    MOTOR_ERROR_UNKNOWN_PHASE_ESTIMATE = 0x04000000,
    MOTOR_ERROR_UNKNOWN_PHASE_VEL = 0x08000000,
    MOTOR_ERROR_UNKNOWN_TORQUE = 0x10000000,
    MOTOR_ERROR_UNKNOWN_CURRENT_COMMAND = 0x20000000,
    MOTOR_ERROR_UNKNOWN_CURRENT_MEASUREMENT = 0x40000000,
    MOTOR_ERROR_UNKNOWN_VBUS_VOLTAGE = 0x80000000,
    MOTOR_ERROR_UNKNOWN_VOLTAGE_COMMAND = 0x100000000,
    MOTOR_ERROR_UNKNOWN_GAINS = 0x200000000,
    MOTOR_ERROR_CONTROLLER_INITIALIZING = 0x400000000,
    MOTOR_ERROR_PHASE_RESISTANCE_OUT_OF_RANGE = 0x00000001,
    MOTOR_ERROR_PHASE_INDUCTANCE_OUT_OF_RANGE = 0x00000002,
    MOTOR_ERROR_UNBALANCED_PHASES = 0x800000000,
    MOTOR_ERROR_ADC_FAILED = 0x00000004,
    MOTOR_ERROR_NOT_IMPLEMENTED_MOTOR_TYPE = 0x00000020,
    MOTOR_ERROR_BRAKE_CURRENT_OUT_OF_RANGE = 0x00000040,
    MOTOR_ERROR_BRAKE_DEADTIME_VIOLATION = 0x00000100,
    MOTOR_ERROR_UNEXPECTED_TIMER_CALLBACK = 0x00000200,
    MOTOR_ERROR_BRAKE_DUTY_CYCLE_NAN = 0x00002000,
    MOTOR_ERROR_DC_BUS_OVER_REGEN_CURRENT = 0x00004000,
    MOTOR_ERROR_DC_BUS_OVER_CURRENT = 0x00008000
} MotorError;

typedef enum {
    SENSORLESS_ESTIMATOR_ERROR_NONE = 0x00000000,
    SENSORLESS_ESTIMATOR_ERROR_UNSTABLE_GAIN = 0x00000001,
    SENSORLESS_ESTIMATOR_ERROR_UNKNOWN_CURRENT_MEASUREMENT = 0x00000002
} SensorlessEstimatorError;

typedef enum {
    ENCODER_MODE_INCREMENTAL = 0,
    ENCODER_MODE_HALL = 1,
    ENCODER_MODE_SINCOS = 2,
    ENCODER_MODE_SPI_ABS_CUI = 256,
    ENCODER_MODE_SPI_ABS_AMS = 257,
    ENCODER_MODE_SPI_ABS_AEAT = 258,
    ENCODER_MODE_SPI_ABS_RLS = 259,
    ENCODER_MODE_SPI_ABS_MA732 = 260
} EncoderMode;

typedef enum {
    CONTROLLER_ERROR_NONE = 0x00000000,
    CONTROLLER_ERROR_OVERSPEED = 0x00000001,
    CONTROLLER_ERROR_INVALID_INPUT_MODE = 0x00000002,
    CONTROLLER_ERROR_UNSTABLE_GAIN = 0x00000004,
    CONTROLLER_ERROR_INVALID_MIRROR_AXIS = 0x00000008,
    CONTROLLER_ERROR_INVALID_LOAD_ENCODER = 0x00000010,
    CONTROLLER_ERROR_INVALID_ESTIMATE = 0x00000020,
    CONTROLLER_ERROR_INVALID_CIRCULAR_RANGE = 0x00000040,
    CONTROLLER_ERROR_SPINOUT_DETECTED = 0x00000080
} ControllerError;

typedef enum {
    ENCODER_ERROR_NONE = 0x00000000,
    ENCODER_ERROR_UNSTABLE_GAIN = 0x00000001,
    ENCODER_ERROR_CPR_POLEPAIRS_MISMATCH = 0x00000002,
    ENCODER_ERROR_NO_RESPONSE = 0x00000004,
    ENCODER_ERROR_UNSUPPORTED_ENCODER_MODE = 0x00000008,
    ENCODER_ERROR_ILLEGAL_HALL_STATE = 0x00000010,
    ENCODER_ERROR_INDEX_NOT_FOUND_YET = 0x00000020,
    ENCODER_ERROR_ABS_SPI_TIMEOUT = 0x00000040,
    ENCODER_ERROR_ABS_SPI_COM_FAIL = 0x00000080,
    ENCODER_ERROR_ABS_SPI_NOT_READY = 0x00000100,
    ENCODER_ERROR_HALL_NOT_CALIBRATED_YET = 0x00000200
} EncoderError;

typedef enum {
    THERMISTOR_CURRENT_LIMITER_ERROR_NONE = 0x00000000,
    THERMISTOR_CURRENT_LIMITER_ERROR_OVER_TEMP = 0x00000001
} ThermistorCurrentLimiterError;

typedef enum {
    LOCKIN_STATE_INACTIVE = 0,
    LOCKIN_STATE_RAMP = 1,
    LOCKIN_STATE_ACCELERATE = 2,
    LOCKIN_STATE_CONST_VEL = 3
} LockinState;

typedef enum {
    ARMED_STATE_DISARMED = 0,
    ARMED_STATE_WAITING_FOR_TIMINGS = 1,
    ARMED_STATE_WAITING_FOR_UPDATE = 2,
    ARMED_STATE_ARMED = 3
} ArmedState;

typedef enum {
    DRV_FAULT_NO_FAULT = 0x00000000,
    DRV_FAULT_FET_LOW_C_OVERCURRENT = 0x00000001,
    DRV_FAULT_FET_HIGH_C_OVERCURRENT = 0x00000002,
    DRV_FAULT_FET_LOW_B_OVERCURRENT = 0x00000004,
    DRV_FAULT_FET_HIGH_B_OVERCURRENT = 0x00000008,
    DRV_FAULT_FET_LOW_A_OVERCURRENT = 0x00000010,
    DRV_FAULT_FET_HIGH_A_OVERCURRENT = 0x00000020,
    DRV_FAULT_OVERTEMPERATURE_WARNING = 0x00000040,
    DRV_FAULT_OVERTEMPERATURE_SHUTDOWN = 0x00000080,
    DRV_FAULT_P_VDD_UNDERVOLTAGE = 0x00000100,
    DRV_FAULT_G_VDD_UNDERVOLTAGE = 0x00000200,
    DRV_FAULT_G_VDD_OVERVOLTAGE = 0x00000400
} DrvFault;

#ifdef __cplusplus
}
#endif

#endif // ODRIVE_ENUMS_H